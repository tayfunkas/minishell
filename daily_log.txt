How our progran works:
1. execute program "minishell"
2. parse arguments based on token
3. Assign datas(str, type..) in the struct "t_token"
4. Check if tokens include A.pipe(|), B.redirection(>. >>. <), C.external command, D.internal command
5. Handle tokens according to the result of 4.

Sep 25th
- splited functions into each '.c' file properly according to each step
- After parsing arguments, our program go to "handle_tokens" function.
- In handle_tokens function, I developed
	1. function "is_external_command" and "is_internal_command"
	2. function "execute_external_command" and "find_cmd_path"
		Now it handles external command with only one word, like "pwd" "ls"
		But it still doesn't work with over a word, like "ls -l". (to be followed-up tomorrow)
Sep 27th
- included all internal commands
- cd, env, exit, pwd works. echo will be checked.
- unset and export will be checked.
- handle_tokens function has been updated.

Sep 30th
- Implemented 'handle_external_commands'part!!!

Oct 1st
- merged the code to handle all internal commands
- updated relevant functions to handle env command
- is_external_command function has been updated to use the copied environment
- some more to handle (multiple arguments for exit and \ for echo"

Oct 4th
- Added **our_env to external functions to work with global variables
- Now we handle echo $USER and also $new_global_variable we created through export
- Multiple pipes are handled

Oct 7th
- Exit function updated, handles all cases

Oct 8th
- Handling redirections (>, >>, <)
- Certain characters within  quotes result in seg fault - needs to be fixed
- Mixing directions with pipes still needs to be handled (cat < input.txt | grep "test")

Oct 11
- Updated cd function to get OLDPWD in environment

Oct 15th
- Created 'readline.supp' file for readline suppression on valgrind

Oct 18th
-$? is handled but a lot of fixes are still required
-Majority of the functions are turned into int for exit_status

HOW TO USE
- Valgrind command:
valgrind --suppressions=./readline.supp --show-leak-kinds=all --leak-check=full ./minishell
- When a new memory leak from readline appears:
  1. valgrind --leak-check=full --show-reachable=yes --error-limit=no --gen-suppressions=all --log-file=minishellraw.log ./minishell
  2. Create 'parse_valgrind_suppressions.sh' file (https://wiki.wxwidgets.org/Parse_valgrind_suppressions.sh)
  3. cat ./minishellraw.log | ./parse_valgrind_suppressions.sh > readline.supp
  4. Open 'readline.supp' file and remain only readline-relevant ones.
  5. Repeat 1-4 to make sure.

After getting rid of readline memory leak, we have:
- uninitialized bytes from wait4() - handle_tokens()
- still reachable from malloc() - handle_tokens()
- still reachable from malloc() - add_token_to_list() - process_token() - tokenize_input()
- still reachable from malloc() - copy_environment()
- still reachable from malloc() - ft_strdup() - copy_environment()
- conditional jump or move depends on uninitialized value from free() - free_external_command()

Nov 1st
- cat < daily_log.txt | grep Oct
cat: grep: No such file or directory
cat: Oct: No such file or directory
- internal function with pipe still doesnt go back to minishell prompt
- some signal handling needs to check
- valgrind
- '|' things with syntax error